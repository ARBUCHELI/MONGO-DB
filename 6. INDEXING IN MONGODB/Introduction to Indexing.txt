# INTRODUCTION TO INDEXING
--------------------------

* Single Field Index
--------------------
8 min
In MongoDB, indexes play an important role in making sure our database performs optimally. Recall, an index is a special data structure that stores a small portion of the collection’s 
data in an easy-to-traverse form. We have already used indexes when we queried by the _id field since MongoDB creates a default index on the _id field for all our documents.

However, we can also create our own custom index by using the .createIndex() method. The syntax looks like this:

db.<collection>.createIndex({ <keys>, <options>, <commitQuorum>)}

We have three main parameters:

	. keys: A document that contains the field and value pairs where the field is the index key and the value describes the type of index for that field.

	. options: A document of various optional options that control index creation.

	. commitQuoroum: A more advanced parameter that gives control over replica sets. We won’t be working with this parameter in this lesson.

In this lesson, we will mostly work with the keys parameter. To learn more about the various other parameters, visit the official documentation. That said, our syntax will look closer to 
this:

db.<collection>.createIndex({ <field>: <type> });

For the keys parameters, we must pass a document with field-type pairs. Fields can be assigned a value of 1 or -1. A value of 1 will sort the index in ascending order, while a value of -1 
would sort the index in descending order. If the field contains a string value, 1 will sort the documents in alphabetical order (A-Z), and -1 will sort the documents in reverse order 
(Z-A).

To see .createIndex() in action, imagine as a university president, we have a collection of every student within your database, called students. A sample document from the students 
collection might look like this:

{ 
  _id: ObjectId(...),
  last_name: "Tapia",
  first_name: "Joseph",
  major: "architecture",
  birth_year: 1988,
  graduation_year: 2012,
  year_abroad: 2011
}

Perhaps we are organizing reunions for students who studied abroad and found ourselves frequently searching the database for students who studied internationally during a particular year. 
Rather than repeatedly querying the entire students collection by the year_abroad field, it would be beneficial to create an index based on this particular field, also known as a single 
field index. We could run the following command:

db.students.createIndex({ year_abroad: 1 });

The above command would create an index on all the documents in the student’s collection based on the year_abroad field, sorted in ascending order.

We can run a query on the indexed field to utilize the indexed year_abroad field. Here’s an example query that uses this new index to search for students who have studied abroad from 2020 
onward:

db.students.find({ year_abroad: { $gt: 2019 }});

Creating a single field index can save us significant time in our query since we’d only be scanning the index for ordered values of the year_abroad field rather than browsing the entire 
collection and examining every document.

Let’s practice creating indexes using the .createIndex() method!

* Instructions
--------------
Checkpoint 1 Passed
1.
We want to create an index that arranges the restaurants according to boroughs. Connect to the restaurants database, and then using the listingsAndReviews collection, create an index 
based on the single field borough so that the results will be in alphabetical order.


Hint
Make sure to call the .createIndex() method on the listingsAndReviews collection using the following syntax. As an argument, provide a document containing the borough field passed in as 
an argument. Assign 1 to the borough field to order the index in ascending order.

db.<collection>.createIndex({ <field>: <1 or -1> })

Need another hint?
Once you put it together, your query should look like this:

db.listingsAndReviews.createIndex({borough: 1})

Checkpoint 2 Passed
2.
Now we want to create an index that lists the different types of cuisines. Create an index based on the single field cuisine so that the index references will be organized in reverse 
alphabetical order.


Hint
Remember you can use the .createIndex() method with the following syntax:

db.<collection>.createIndex({ <field>: <1 or -1> })

Need another hint?
Remember to assign a value of -1 to the cuisine field to organize the index in reverse alphabetical order. Once you put it together, your query should look like this:

mongosh
-------
test> use restaurants
switched to db restaurants
restaurants> db.listingsAndReviews.createIndex({ borough: 1} );
borough_1
restaurants> db.listingsAndReviews.createIndex({ cuisine: -1 });
cuisine_-1

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Performance Insights with .explain()
--------------------------------------
10 min
Since indexing in MongoDB is tied closely to database performance, it would be ideal to have a way to see how our indexes impact our queries. The .explain() method can offer us insight 
into the performance implications of our indexes. The method has the following syntax:

db.<collection>.find(...).explain(<verbose>)

Note that the method is appended to the .find() method. It also takes one string parameter named verbose that specifies what the method should explain. The possible values are: 
"queryPlanner", "executionStats", and "allPlansExecution". Each value offers meaningful insights on a query. To gain insights regarding the execution of the winning query plan for a 
query, we can use the "executionStats" option.

To see .explain() in action, let’s refer back to our study abroad example from the previous exercise. Let’s examine how to use this method by appending the .explain() method to our query 
from the previous exercise:

db.students.find({ year_abroad: { $gt: 2019 }}).explain('executionStats');

Running our query with "executionStats" outputs a series of objects containing detailed information about our operation. We won’t include the entire output below, but rather we’ll focus 
on a specific object, called executionStats.

If we were to execute the .explain() method before creating our index on the year_abroad field, the output might look something like this:

executionStats: {
  executionSuccess: true,
  nReturned: 1336,
  executionTimeMillis: 140,
  totalKeysExamined: 0,
  totalDocsExamined: 5555,
  executionStages: {
    …
  }
}

Examine the nReturned, totalDocsExamined, and executionTimeMillis fields. Notice that out of 5555 total documents, only 1336 were returned by our query, which took approximately 140 
milliseconds.

Now let’s look at what the output of our query might look like after we index the year_abroad field:

executionStats: {
  executionSuccess: true,
  nReturned: 1336,
  executionTimeMillis: 107,
  totalKeysExamined: 1336,
  totalDocsExamined: 1336,
  executionStages: {
   …
  }
}

Check out the nReturned and totalDocsExamined fields again. Notice anything?

When we ran our query after creating our index, we still returned 1336 documents, but instead of examining the entire collection, 5555 documents, we only examined the 1336 we returned.
This is because our query first scanned the index to identify documents that matched our filter, then returned only the corresponding documents without browsing every document in the 
collection.

Take a look at the executionTimeMillis for each query. You’ll also notice that our query after creating the index took 107 milliseconds, while our query before creating the index took a 
bit longer, 140 milliseconds. This might not seem like much, but if we were working with a collection containing tens or hundreds of thousands of documents, the time difference would 
likely be much more significant.

Let’s practice using the .explain() method to see the power of indexing!

* Instructions
--------------
Checkpoint 1 Passed
1.
Let’s create an index on the name field for documents in the listingsAndReviews collection and compare the execution stats of a query with and without the index to ensure the index is 
performing efficiently.

First, query the listingsAndReviews collection for a restaurant named "Osaka Japanese Fusion". Use the .explain() method with the "executionStats" argument to see the execution stats for 
your query without using an index. Take note of the nReturned and totalDocsExamined fields.


Hint
You can use the .find() method to search for a document in a collection. Be sure to provide the filter { name: "Osaka Japanese Fusion" } as an argument. Append the .explain() method with 
"executionStats" as an argument to see information about your query.

Need another hint?
Once you put it together, your query should look like this:

db.listingsAndReviews.find({name: "Osaka Japanese Fusion"}).explain("executionStats")

Checkpoint 2 Passed
2.
Next, create an index on the name field in ascending order.


Hint
Make sure to append the .createIndex() method to the collection with a document containing the relevant field passed in as an argument. Assign 1 to the name field to organize the index in 
ascending or alphabetical order.

Need another hint?
Once you put it together, your query should look like this:

db.listingsAndReviews.createIndex({name: 1})

Checkpoint 3 Passed
3.
Query the listingsAndReviews collection again for the restaurant with the name of "Osaka Japanese Fusion". Use the .explain() method with the string "executionStats" as an argument to see 
the performance of your query using your newly created index. Do you notice any difference in the query’s performance?


Hint
You can use the .find() method to search for a document in a collection. Be sure the chain the .explain() method to your query to see information about its execution. In particular, take 
note of the nReturned and totalDocsExamined fields.

Need another hint?
Once you put it together, your query should look like this:

db.listingsAndReviews.find({ name: 'Osaka Japanese Fusion' }).explain('executionStats')

mongosh
-------
test> use restaurants
switched to db restaurants
restaurants> db.listingsAndReviews.find({ name: 'Osaka Japanese Fusion' }).explain('executionStats');
{
  explainVersion: '1',
  queryPlanner: {
    namespace: 'restaurants.listingsAndReviews',
    indexFilterSet: false,
    parsedQuery: { name: { '$eq': 'Osaka Japanese Fusion' } },
    maxIndexedOrSolutionsReached: false,
    maxIndexedAndSolutionsReached: false,
    maxScansToExplodeReached: false,
    winningPlan: {
      stage: 'FETCH',
      inputStage: {
        stage: 'IXSCAN',
        keyPattern: { name: 1 },
        indexName: 'name_1',
        isMultiKey: false,
        multiKeyPaths: { name: [] },
        isUnique: false,
        isSparse: false,
        isPartial: false,
        indexVersion: 2,
        direction: 'forward',
        indexBounds: {
          name: [ '["Osaka Japanese Fusion", "Osaka Japanese Fusion"]' ]
        }
      }
    },
    rejectedPlans: []
  },
  executionStats: {
    executionSuccess: true,
    nReturned: 1,
    executionTimeMillis: 0,
    totalKeysExamined: 1,
    totalDocsExamined: 1,
    executionStages: {
      stage: 'FETCH',
      nReturned: 1,
      executionTimeMillisEstimate: 0,
      works: 2,
      advanced: 1,
      needTime: 0,
      needYield: 0,
      saveState: 0,
      restoreState: 0,
      isEOF: 1,
      docsExamined: 1,
      alreadyHasObj: 0,
      inputStage: {
        stage: 'IXSCAN',
        nReturned: 1,
        executionTimeMillisEstimate: 0,
        works: 2,
        advanced: 1,
        needTime: 0,
        needYield: 0,
        saveState: 0,
        restoreState: 0,
        isEOF: 1,
        keyPattern: { name: 1 },
        indexName: 'name_1',
        isMultiKey: false,
        multiKeyPaths: { name: [] },
        isUnique: false,
        isSparse: false,
        isPartial: false,
        indexVersion: 2,
        direction: 'forward',
        indexBounds: {
          name: [ '["Osaka Japanese Fusion", "Osaka Japanese Fusion"]' ]
        },
        keysExamined: 1,
        seeks: 1,
        dupsTested: 0,
        dupsDropped: 0
      }
    }
  },
  command: {
    find: 'listingsAndReviews',
    filter: { name: 'Osaka Japanese Fusion' },
    '$db': 'restaurants'
  },
  serverInfo: {
    host: '76bceda8ac1b',
    port: 27017,
    version: '5.0.9',
    gitVersion: '6f7dae919422dcd7f4892c10ff20cdc721ad00e6'
  },
  serverParameters: {
    internalQueryFacetBufferSizeBytes: 104857600,
    internalQueryFacetMaxOutputDocSizeBytes: 104857600,
    internalLookupStageIntermediateDocumentMaxSizeBytes: 104857600,
    internalDocumentSourceGroupMaxMemoryBytes: 104857600,
    internalQueryMaxBlockingSortMemoryUsageBytes: 104857600,
    internalQueryProhibitBlockingMergeOnMongoS: 0,
    internalQueryMaxAddToSetBytes: 104857600,
    internalDocumentSourceSetWindowFieldsMaxMemoryBytes: 104857600
  },
  ok: 1
}
restaurants> db.listingsAndReviews.createIndex({ name: 1 });
name_1
restaurants> db.listingsAndReviews.find({ name: 'Osaka Japanese Fusion' }).explain('executionStats');
{
  explainVersion: '1',
  queryPlanner: {
    namespace: 'restaurants.listingsAndReviews',
    indexFilterSet: false,
    parsedQuery: { name: { '$eq': 'Osaka Japanese Fusion' } },
    maxIndexedOrSolutionsReached: false,
    maxIndexedAndSolutionsReached: false,
    maxScansToExplodeReached: false,
    winningPlan: {
      stage: 'FETCH',
      inputStage: {
        stage: 'IXSCAN',
        keyPattern: { name: 1 },
        indexName: 'name_1',
        isMultiKey: false,
        multiKeyPaths: { name: [] },
        isUnique: false,
        isSparse: false,
        isPartial: false,
        indexVersion: 2,
        direction: 'forward',
        indexBounds: {
          name: [ '["Osaka Japanese Fusion", "Osaka Japanese Fusion"]' ]
        }
      }
    },
    rejectedPlans: []
  },
  executionStats: {
    executionSuccess: true,
    nReturned: 1,
    executionTimeMillis: 0,
    totalKeysExamined: 1,
    totalDocsExamined: 1,
    executionStages: {
      stage: 'FETCH',
      nReturned: 1,
      executionTimeMillisEstimate: 0,
      works: 2,
      advanced: 1,
      needTime: 0,
      needYield: 0,
      saveState: 0,
      restoreState: 0,
      isEOF: 1,
      docsExamined: 1,
      alreadyHasObj: 0,
      inputStage: {
        stage: 'IXSCAN',
        nReturned: 1,
        executionTimeMillisEstimate: 0,
        works: 2,
        advanced: 1,
        needTime: 0,
        needYield: 0,
        saveState: 0,
        restoreState: 0,
        isEOF: 1,
        keyPattern: { name: 1 },
        indexName: 'name_1',
        isMultiKey: false,
        multiKeyPaths: { name: [] },
        isUnique: false,
        isSparse: false,
        isPartial: false,
        indexVersion: 2,
        direction: 'forward',
        indexBounds: {
          name: [ '["Osaka Japanese Fusion", "Osaka Japanese Fusion"]' ]
        },
        keysExamined: 1,
        seeks: 1,
        dupsTested: 0,
        dupsDropped: 0
      }
    }
  },
  command: {
    find: 'listingsAndReviews',
    filter: { name: 'Osaka Japanese Fusion' },
    '$db': 'restaurants'
  },
  serverInfo: {
    host: '76bceda8ac1b',
    port: 27017,
    version: '5.0.9',
    gitVersion: '6f7dae919422dcd7f4892c10ff20cdc721ad00e6'
  },
  serverParameters: {
    internalQueryFacetBufferSizeBytes: 104857600,
    internalQueryFacetMaxOutputDocSizeBytes: 104857600,
    internalLookupStageIntermediateDocumentMaxSizeBytes: 104857600,
    internalDocumentSourceGroupMaxMemoryBytes: 104857600,
    internalQueryMaxBlockingSortMemoryUsageBytes: 104857600,
    internalQueryProhibitBlockingMergeOnMongoS: 0,
    internalQueryMaxAddToSetBytes: 104857600,
    internalDocumentSourceSetWindowFieldsMaxMemoryBytes: 104857600
  },
  ok: 1
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Compound Indexes
------------------
10 min
In addition to single field indexes, MongoDB gives us the ability to create compound indexes. Compound indexes contain references to multiple fields within a document and support queries 
that match on multiple fields. Let’s have a look at the syntax for creating a compound index:

db.<collection>.createIndex({ 
  <field>: <type>, 
  <field2>: <type>, 
  …
})

Similar to single field indexes, MongoDB will scan our index for matching values, then return the corresponding documents. With compound indexes, the order of fields is important. To 
understand why, let’s return to our example from the first exercise about the university president.

Imagine that as president we wanted to plan reunions not just for students who studied abroad during a particular year, but also for students who studied abroad in a particular country. 
We could create a compound index on two fields: study_abroad_nation and year_abroad, like so:

db.students.createIndex({ 
  study_abroad_nation: 1, 
  year_abroad: -1 
});

This creates a single index that references two fields: study_abroad_nation in ascending, or alphabetical order, and year_abroad in descending, or reverse chronological order.

Because of how the fields are ordered, references within this index will be sorted first by the study_abroad_nation field. Within each value of the study_abroad_nation field, references 
will be sorted by the year_abroad field. This is an important consideration in determining how well our indexes will be able to support sort operations in our queries.

Now that we’ve created this compound index, anytime we query on these two fields, MongoDB will automatically employ this index to support our search.

The below query would be a use case for our compound index:

db.students.find({ 
  study_abroad_nation: "Brazil", 
  year_abroad: 2012 
});

Compound indexes can also support queries on any prefix, or a beginning subset of the indexed fields. For example, consider the following compound index:

db.students.createIndex({ 
  study_abroad_nation: 1, 
  year_abroad: -1, 
  graduation_year: 1 
});

In addition to supporting a query that matches on the study_abroad_nation, year_abroad and graduation_year fields, this index would also be able to support queries on the following 
fields:

	. study_abroad_nation

	. study_abroad_nation and year_abroad

This index would not, however, be able to support queries on the following fields:

	. year_abroad

	. graduation_year

	. year_abroad and graduation_year

As each index must be updated as documents change, unnecessary indexes can affect the write speed to our database. Make sure to consider if a compound index would be more efficient than 
creating multiple distinct single-field indexes to support your queries.

Let’s practice creating and using compound indexes!

* Instructions
--------------
Checkpoint 1 Passed
1.
We’ve realized that creating one compound index would be more efficient than two single field indexes. Using the same listingsAndReviews collection, create an index based on the fields 
borough and cuisine so that the results would be in ascending order for borough and descending order for cuisine.


Hint
Remember to first run the command use restaurants to connect to the restaurants database. Make sure to append .createIndex() to the listingsAndReviews collection with the relevant 
fields.

Need another hint?
Provide 1 as a value to order the index field in ascending order and -1 for descending order.

Once you put it together, your query should look like this:

db.listingsAndReviews.createIndex({borough: 1, cuisine: -1})

Checkpoint 2 Failed, try again
2.
Using the new compound index, we want to query only Chinese restaurants with a restaurant_id greater than "42000000". Create a query that satisfies these parameters.


Hint
Make sure to use the .find() method to query the listingsAndReviews collection. Be sure to query on the cuisine and restaurant_id fields.

Need another hint?
Use the $gt operator to find restaurant_id values that are greater than "42000000".

Once you put it together, your query should look like this:

db.listingsAndReviews.find({ cuisine: "Chinese", restaurant_id: { $gt: "42000000" } })

mongosh
-------
test> use restaurants
switched to db restaurants
restaurants> db.listingsAndReviews.createIndex({ borough: 1, cuisine: -1 });
borough_1_cuisine_-1

restaurants> db.listingsAndReviews.find({ cuisine: "Chinese", restaurant_id: { $gt: "42000000"}});
[
  {
    _id: ObjectId("5eb3d669b31de5d588f484e0"),
    address: {
      building: '770',
      coord: [ -74.00959999999999, 40.636179 ],
      street: '59 Street',
      zipcode: '11220'
    },
    borough: 'Brooklyn',
    cuisine: 'Chinese',
    grades: [
      {
        date: ISODate("2014-10-09T00:00:00.000Z"),
        grade: 'Z',
        score: 22
      }
    ],
    name: 'D.C.Plzz Seafood',
    restaurant_id: '50014008'
  },
  {
    _id: ObjectId("5eb3d669b31de5d588f47b13"),
    address: {
      building: '40-75',
      coord: [ -73.8682266, 40.7471902 ],
      street: 'Junction Boulevard',
      zipcode: '11368'
    },
    borough: 'Queens',
    cuisine: 'Chinese',
    grades: [
      {
        date: ISODate("2014-06-19T00:00:00.000Z"),
        grade: 'A',
        score: 8
      },
      {
        date: ISODate("2014-01-14T00:00:00.000Z"),
        grade: 'A',
        score: 7
      }
    ],
    name: 'May Chun Garden',
    restaurant_id: '50005130'
  },
  {
    _id: ObjectId("5eb3d669b31de5d588f47a2f"),
    address: {
      building: '2102',
      coord: [ -73.8436674, 40.8562685 ],
      street: 'Eastchester Road',
      zipcode: '10461'
    },
    borough: 'Bronx',
    cuisine: 'Chinese',
    grades: [
      {
        date: ISODate("2014-07-16T00:00:00.000Z"),
        grade: 'A',
        score: 7
      },
      {
        date: ISODate("2013-12-18T00:00:00.000Z"),
        grade: 'A',
        score: 10
      }
    ],
    name: 'Golden China Pavilion',
    restaurant_id: '50004482'
  },
  {
    _id: ObjectId("5eb3d669b31de5d588f474c8"),
    address: {
      building: '41-28',
      coord: [ -73.829437, 40.757178 ],
      street: 'Main Street',
      zipcode: '11355'
    },
    borough: 'Queens',
    cuisine: 'Chinese',
    grades: [
      {
        date: ISODate("2014-09-02T00:00:00.000Z"),
        grade: 'A',
        score: 10
      },
      {
        date: ISODate("2014-04-03T00:00:00.000Z"),
        grade: 'A',
        score: 12
      },
      {
        date: ISODate("2013-07-23T00:00:00.000Z"),
        grade: 'A',
        score: 10
      }
    ],
    name: 'Super Snacks',
    restaurant_id: '50001320'
  }
]
restaurants> 

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Multikey Index on Single Fields
---------------------------------
3 min
How do MongoDB indexes handle fields whose values are arrays? Conveniently, MongoDB automatically creates what’s known as a multikey index whenever an index on a array field is created. 
Multikey indexes provide an index key for each element in the indexed array.

Suppose we had a document within the students collection that had a field, sports with an array as its value:

{ 
  _id: ObjectId(...),
  last_name: "Tapia",
  first_name: "Joseph",
  major: "architecture",
  birth_year: 1988,
  graduation_year: 2012 ,
  sports: ["rowing", "boxing"]
}

We could create a multikey index on this field in the same way we would create any other single-field index:

db.students.createIndex({ sports : 1 });

This would create an index that references the sports field for every document in the collection. Since sports is an array field, the resulting multikey index would contain individual 
references to each element in the array. We specified ascending order for our index so the values would be organized in alphabetical order.

Note that this example discusses multikey single field indexes. Next we’ll learn about some important considerations to keep in mind when creating compound multikey indexes.

Let’s spend some time practicing creating and using multikey indexes!

* Instructions
--------------
Checkpoint 1 Passed
1.
Switch to the restaurants database. Inside the listingsAndReviews collection, create a multikey index on the grades field in ascending order.


Hint
Remember to first run the command use restaurants to access the listingsAndReviews collection.

Make sure to call the .createIndex() method on the listingsAndReviews collection with the relevant fields. Provide 1 as a value to order the field values in ascending order and -1 for descending order.

Need another hint?
Provide `1` as a value to order the field values in ascending order and `-1` for descending order. Once you put it together, your query should look like this:
db.listingsAndReviews.createIndex({grades: 1})

mongosh
-------
test> use restaurants;
switched to db restaurants
restaurants> db.listingsAndReviews.createIndex({ grades: 1 });
grades_1
restaurants>

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Multikey Index on Compound Fields
-----------------------------------
3 min
Is it possible to create a compound multikey index in MongoDB? The answer is yes, with a very important caveat - only one of the indexed fields can have an array as its value.

For example, suppose we had a document within a students collection with two fields with arrays as their values: sports and clubs.

{ 
  _id: ObjectId(...),
  last_name: "Tapia",
  first_name: "Joseph",
  major: "architecture",
  birth_year: 1988,
  graduation_year: 2012 ,
  sports: ["rowing", "boxing"],
  clubs: [“Honor Society”, “Student Government”, “Yearbook Committee”]
}

A single compound index can not be created on both the sports and clubs fields. We could, however, successfully create a compound multikey index on sports or clubs along with any of the 
other fields.

For example, either of the following would successfully create a compound multikey index:

db.students.createIndex({ sports: 1, major: 1 });
db.students.createIndex({ clubs: -1, graduation_year: -1 });

If we wanted to index both the sports and clubs fields, we’d have to create two separate indexes for them.

Let’s practice creating a compound multikey index!

* Instructions
--------------
Checkpoint 1 Passed
1.
Connect to the restaurants database. Inside the listingsAndReviews collection, create a multikey index with the fields cuisine, in ascending order, and grades, in descending order.


Hint
Remember to run the command use restaurants to access the listingsAndReviews collection. You can call the .createIndex() method on the listingsAndReviews collection to create a multikey 
index.

Need another hint?
Provide 1 as a value to order the field values in ascending order and -1 for descending order.Once you put it together, your query should look like this:

db.listingsAndReviews.createIndex({cuisine: 1, grades: -1})

mongosh
-------
test> use restaurants
switched to db restaurants
restaurants> db.listingsAndReviews.createIndex({ cuisine: 1, grades: -1 });
cuisine_1_grades_-1

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Deleting an Index
-------------------
5 min
Each time we make changes to a collection, any indexes associated with that collection must also be updated. In this way, unnecessary indexes can slow down the performance of certain CRUD 
operations. This is why it is important to review our indexes and remove any that are redundant or not being used.

Suppose, after some reflection, we discovered that a compound index can handle all the queries we need to make, instead of the single field indexes we originally were relying on. Once 
we’ve created the compound index, it would be a good idea to identify and remove any unnecessary indexes.

First, we can use the .getIndexes() method to see all of the indexes that exist for a particular collection.

Consider a collection called students that has multiple indexes:

db.students.getIndexes();

Might output:

[
   {  v : 1,
      key : { _id : 1 },
      name : '_id_'
   },
   {
      v : 1,
      key : { sports : -1 },
      name : 'sports_-1'
   },
   {
      v : 1,
      key : { sports : -1, graduation year : -1 },
      name : 'sports_-1_graduation_year_-1'
   }
]

Now that we have a list of our indexes for the students collection, we can see that both the second and third indexes index the sports key in descending order. Since compound indexes can 
support queries on any of the prefixed fields, our third index, named 'sports_-1_graduation_year_-1', can support queries on both sports and graduation_year.

This means that our second index, 'sports_-1', is redundant. MongoDB gives us another method, .dropIndex(), that allows us to remove an index, without modifying the original collection. 
We can use it to delete the 'sports_-1' index:

db.students.dropIndex('sports_-1');

The above command would delete the index, and then we can confirm by running db.students.getIndexes(); again:

[
   {  v : 1,
      key : { _id : 1 },
      name : '_id_'
   },
   {
      v : 1,
      key : { sports : -1, graduation year : -1 },
      name : 'sports_-1_graduation_year_-1'
   }
]

Getting rid of unnecessary indexes can free up disk space and speed up the performance of write operations, so as you start to use indexes more, it is worth regularly scrutinizing them to 
see which, if any, you can remove.

Let’s practice removing an index from our restaurants collection!

* Instructions
--------------
Checkpoint 1 Passed
1.
We’ve created several indexes throughout this lesson. Run the .getIndexes() method to take inventory of all the indexes we have so far.


Hint
Remember to first run the command use restaurants to access the listingsAndReviews collection. Make sure to append the .getIndexes() method to the listingsAndReviews collection to see a 
list of all the indexes in this collection.

Need another hint?
Once you put it together, your query should look like this:

db.listingsAndReviews.getIndexes()

Checkpoint 2 Passed
2.
Since we have one compound index that references both borough and cuisine, the indexes named borough_1 and cuisine_-1 are now redundant. Use the .dropIndex() method to delete the 
borough_1 index from the listingsAndReviews collection.


Hint
Append the .dropIndex() method to the listingsAndReviews collection, passing in the name of the index you want to remove as the argument.

Need another hint?
Once you put it together, your query should look like this:

db.listingsAndReviews.dropIndex("borough_1")

mongosh
-------
test> use restaurants;
switched to db restaurants
restaurants> db.listingsAndReviews.getIndexes();
[
  { v: 2, key: { _id: 1 }, name: '_id_' },
  {
    v: 2,
    key: { cuisine: 1, grades: -1 },
    name: 'cuisine_1_grades_-1'
  },
  { v: 2, key: { grades: 1 }, name: 'grades_1' },
  {
    v: 2,
    key: { borough: 1, cuisine: -1 },
    name: 'borough_1_cuisine_-1'
  },
  { v: 2, key: { name: 1 }, name: 'name_1' },
  { v: 2, key: { borough: 1 }, name: 'borough_1' },
  { v: 2, key: { cuisine: -1 }, name: 'cuisine_-1' }
]
restaurants> db.listingsAndReviews.dropIndex('borough_1');
{ nIndexesWas: 7, ok: 1 }
restaurants> 

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

























































































































































