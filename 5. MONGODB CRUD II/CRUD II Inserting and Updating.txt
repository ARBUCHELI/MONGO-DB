# CRUD II: INSERTING AND UPDATING
---------------------------------

* The _id Field
---------------
5 min
By this point, we’ve learned the fundamentals of querying data in MongoDB. In this lesson, we’ll learn how to insert new documents, and update existing ones.

As you continue to work with documents in MongoDB, you may notice one field that exists across every document: the _id field. It might look similar to this:

_id: ObjectId("5eb3d668b31de5d588f4305b")

The _id field plays a vital role in every document inside of a MongoDB collection, and it has a few distinct characteristics:

	. The _id field is required for every document in a collection and must be unique.

	. MongoDB automatically generates an ObjectId for the _id field if no value is provided.

	. Developers can specify the _id with something other than an ObjectId such as a number or random string, if desired.

	. The _id field is immutable, and once a document has an assigned _id, it cannot be updated or changed.

The ObjectId is a 12-byte data type that is commonly used for the _id field. When generated automatically, each ObjectId contains an embedded timestamp which is generally unique. This 
allows documents to be inserted in order of creation time (or very close to it) and for users to roughly sort their results by creation time if necessary. While we won’t explicitly need 
the _id field to update or create new documents, it’s important to note that this is how MongoDB identifies each unique document that is inserted or updated in a collection.

Let’s return to our restaurants collection to look at the _id fields that currently exist in our documents.

* Instructions
--------------
Checkpoint 1 Passed
1.
Connect to the restaurants database, then using the listingsAndReviews collection, query for all the documents in the collection using the .find() method. Take a moment to observe the _id 
field in each document.


Hint
Be sure to connect to run the command use restaurants to connect to the restaurants database first. To query for all the documents in a collection, you can use the .find() method with the 
following syntax:

db.<collection>.find()

Need another hint?
Once you put it together, your query should look like this:

mongosh
-------
test> use restaurants
switched to db restaurants
restaurants> db.listingsAndReviews.find()

[
  {
    _id: ObjectId("5eb3d668b31de5d588f43081"),
    address: {
      building: '543',
      coord: [ -73.9922175, 40.7543506 ],
      street: '8 Avenue',
      zipcode: '10018'
    },
    borough: 'Manhattan',
    cuisine: 'American',
    grades: [
      {
        date: ISODate("2014-12-29T00:00:00.000Z"),
        grade: 'A',
        score: 7
      },
      {
        date: ISODate("2014-06-26T00:00:00.000Z"),
        grade: 'A',
        score: 12
      },
      {
        date: ISODate("2013-06-03T00:00:00.000Z"),
        grade: 'A',
        score: 13
      },
      {
        date: ISODate("2012-05-29T00:00:00.000Z"),
        grade: 'A',
        score: 2
      },
      {
        date: ISODate("2012-01-26T00:00:00.000Z"),
        grade: 'A',
        score: 10
      }
    ],
    name: 'Wakamba',
    restaurant_id: '40564625'
  },

  ...



------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Inserting a Single Document
-----------------------------
11 min
Now that we know how MongoDB identifies each individual document, let’s focus on the Create aspect of CRUD operations. Specifically, how do we start adding new documents to our 
collections? In MongoDB, we can use the .insertOne() method to insert a single new document!

The syntax for the method looks as follows:

db.<collection>.insertOne(
  <new_document>, 
  {
    writeConcern: <document>,
  }
);

The .insertOne() method has a single required parameter, the document to be inserted, and a second optional parameter named writeConcern. We won’t be working with the writeConcern 
parameter in this course, but more details about the parameter can be found in the official MongoDB documentation. For now, know that it’s an optional parameter that allows us to specify 
how we want our write requests to be acknowledged by MongoDB.

Let’s take a look at an example where we insert a single document into a videogames collection:

db.videogames.insertOne({
  title: "Elden Ring",
  year: 2022,
  company: "Fromsoftware"
});

When a document is successfully inserted with .insertOne(), the output is an object with a field named acknowledged (related to the writeConcern parameter we mentioned earlier) with the 
value true and a field named insertedId where the value is the _id field for the newly inserted document. Here is what it looks like:

{
  "acknowledged": true,
  "insertedId": ObjectId("5fd989674e6b9ceb8665c63d")
}

Note that if we try to insert into a specified collection that does not exist, MongoDB will create one and insert the document into the newly created collection.

Now, let’s practice using the .insertOne() method by returning to our listingsAndReviews collection inside the restaurants database.

* Instructions
--------------
Checkpoint 1 Passed
1.
Connect to the restaurants database. Then, query the listingsAndReviews collection for all its documents to see what the structure of each document looks like.


Hint
Be sure to run the use restaurants command first to connect to the restaurants database. Then, use the .find() method to query for all the documents inside the listingsAndReviews 
collection.

Need another hint?
Once you put it together, your query should look like this:
db.listingsAndReviews.find()

Checkpoint 2 Passed
2.
Use the .insertOne() method to insert a new document in the listingsAndReviews collection with the following properties:

name: "Elvins",
cuisine: "American",
restaurant_id: "40564243"


Hint
To insert a new document into a collection, use the .insertOne() method with the following syntax:

db.<collection>.insertOne({ <field1>: <value1>, <field2>: <value2>, ... })

Need another hint?
You can call the .insertOne() method on the listingsAndReviews collection to add a new document to this collection. As an argument, pass in a document with the fields and values specified 
above.

Once you put it together, your query should look like this:

db.listingsAndReviews.insertOne({ name: "Elvins", cuisine: "American", restaurant_id: "40564243" })

Checkpoint 3 Passed
3.
Using .findOne(), search for the document you just inserted into the collection by its restaurant_id.


Hint
To query a collection for a single document using the findOne() method, you can use the following syntax:

db.<collection>.findOne({ <field>: <value> })

Need another hint?
You can call the .findOne() method on the listingsAndReviews collection to query this collection for a single document. As an argument, pass in a query document where the field is 
restaurant_id and the value is the string "40564243".

Once you put it together, your query should look like this:

db.listingsAndReviews.findOne({ restaurant_id: "40564243" })

mongosh
-------
test> use restaurants
switched to db restaurants
restaurants> db.listingsAndReviews.find()

[
  {
    _id: ObjectId("5eb3d668b31de5d588f43081"),
    address: {
      building: '543',
      coord: [ -73.9922175, 40.7543506 ],
      street: '8 Avenue',
      zipcode: '10018'
    },
    borough: 'Manhattan',
    cuisine: 'American',
    grades: [
      {
        date: ISODate("2014-12-29T00:00:00.000Z"),
        grade: 'A',
        score: 7
      },
      {
        date: ISODate("2014-06-26T00:00:00.000Z"),
        grade: 'A',
        score: 12
      },
      {
        date: ISODate("2013-06-03T00:00:00.000Z"),
        grade: 'A',
        score: 13
      },
      {
        date: ISODate("2012-05-29T00:00:00.000Z"),
        grade: 'A',
        score: 2
      },
      {
        date: ISODate("2012-01-26T00:00:00.000Z"),
        grade: 'A',
        score: 10
      }
    ],
    name: 'Wakamba',
    restaurant_id: '40564625'
  },

  ...


restaurants> db.listingsAndReviews.insertOne({name: "Elvins", cuisine: "American", restaurant_id: "40564243"});

{
  acknowledged: true,
  insertedId: ObjectId("660a8c272fa491ee081811c0")
}

restaurants> db.listingsAndReviews.findOne({restaurant_id: "40564243"});

{
  _id: ObjectId("660a8a65368569f951a29ace"),
  name: 'Elvins',
  cuisine: 'American',
  restaurant_id: '40564243'
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Inserting Multiple Documents
------------------------------
12 min
We have just used .insertOne() to insert a single document into a collection, but what if we want to insert multiple documents into a collection? Here’s where the MongoDB .insertMany() 
method comes in.

As its name suggests, .insertMany() will insert multiple documents into a collection. Much like .insertOne(), if the collection we’ve specified does not exist, one will be created.

The syntax for the method is as follows:

db.<collection>.insertMany(
  [<document1>, <document2>, ...],
  {
    writeConcern: <document>,
    ordered: <boolean>
  }
);

This method has three parameters:

	1. An array of documents; the documents we want to add to the collection.

	2. A parameter named writeConcern.

	3. A parameter named ordered.

The ordered parameter can be handy since it allows us to specify if MongoDB should perform an ordered or unordered insert. If set to false, documents are inserted in an unordered format. 
If set to true, the default behavior, MongoDB will insert the documents in the order given in the array.

It’s worth noting that with ordered inserts, if a single document fails to be inserted, the entire insert operation will cease, and any remaining documents will not be inserted. On the 
other hand, unordered inserts will continue in the case of an insert failure and attempt to insert any remaining documents.

Let’s look at an example of .insertMany() on a collection named students:

db.students.insertMany([
  {
    name: "Mia Ramirez",
    age: 15
  },
  {
    name: "Kiv Huang",
    age: 17
  },
  {
    name: "Sam Soto",
    age: 16
  }
], { ordered: true })

The command above will insert the documents in the order specified. Below you will find the output of the command with an additional note that indicates which _id represents which 
document.

{
  acknowledged: true,
  insertedIds: {
    '0': ObjectId("63054a5376742c0e5a0cfafb"), // Mia
    '1': ObjectId("63054a5376742c0e5a0cfafc"), // Kiv
    '2': ObjectId("63054a5376742c0e5a0cfafd") // Sam
  }
}

Let’s practice adding multiple new restaurants to our listingsAndReviews collection!

* Instructions
--------------
Checkpoint 1 Passed
1.
Connect to the restaurants database. Insert two new documents in an ordered fashion into the listingsAndReviews collection. The documents should have the following properties, 
respectively:

// 1st document
  name: "Boucherie",
  borough: "Manhattan",
  cuisine: "American",
  restaurant_id: "49246215"

// 2nd document
  name: "Carmines",
  borough: "Manhattan",
  cuisine: "Italian",
  restaurant_id: "48259401"


Hint
Remember to include each document in an array, and pass that array into the .insertMany() method as the first argument. Use the following syntax for the insertMany() method:

db.<collection>.insertMany(
  [<document1>, <document2>, ...],
  {
    ordered: <boolean>
  }
);

Need another hint?
You can call the .insertMany() method on the listingsAndReviews collection to insert multiple documents into this collection. As an argument, pass in an array of documents with the fields 
and values provided to you.

Once you put it together, your query should look like this:

db.listingsAndReviews.insertMany([
  {
    name: "Boucherie", 
    borough: "Manhattan", 
    cuisine: "American", 
   restaurant_id: "49246215"
  }, 
  {
    name: "Carmines", 
    borough: "Manhattan", 
    cuisine: "Italian", 
    restaurant_id: "48259401"
  }
])

Checkpoint 2 Passed
2.
Using .findOne() method, query for one of the documents that you just inserted using the name field.


Hint
To query a collection for a single document using the findOne() method, you can use the following syntax:

db.<collection>.findOne({ <field>: <value> })

Need another hint?
Be sure to pass in a query document that specifies name as the field, and "Boucherie" or "Carmines" as the value.

Once you put it together, your query should look as follows:

mongosh
-------
test> use restaurants
switched to db restaurants
restaurants> db.listingsAndReviews.insertMany([{name: "Boucherie", borough: "Manhattan", cuisine: "American", restaurant_id: "49246215"},{name: "Carmines", borough: "Manhattan", cuisine: "Italian", restaurant_id: "48259401"}]);
{
  acknowledged: true,
  insertedIds: {
    '0': ObjectId("660a8ea1e81fd8de3e942ca6"),
    '1': ObjectId("660a8ea1e81fd8de3e942ca7")
  }
}
restaurants> db.listingsAndReviews.findOne({name: "Boucherie"});
{
  _id: ObjectId("660a8ea1e81fd8de3e942ca6"),
  name: 'Boucherie',
  borough: 'Manhattan',
  cuisine: 'American',
  restaurant_id: '49246215'
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

Updating a Single Document
13 min
Now that we have explored a few Create operations, let’s look at operations that Update data.

In MongoDB, we can use the .updateOne() method to update a single document. The method finds the first document that matches specific filter criteria and applies specified update modifications. Note that it updates the first matching document, even if multiple documents match the criteria.

Let’s take a look at the syntax for the .updateOne() method:

db.<collection>.updateOne(<filter>, <update>, <options>)

The method has three parameters:

filter: A document that provides selection criteria for the document to update.
update: A document that specifies any modifications to be applied. This parameter gives us quite a bit of flexibility, allowing us to modify existing fields, insert new ones, or even replace an entire document.
options: A document that includes any additional specifications for our update operation such as upsert and writeConcern.
To explore the importance of each of these parameters and how the updateOne() method works, consider a third-party retail store for used smartphones. The store keeps all their information in a collection called products, where each document holds information regarding a specific type of smartphone:

{ 
  _id: ObjectId("507f1fg7bcf865d799439h11"), 
  title: "iPhoneX", 
  price: 1000,
  stock: 25 
},
{ 
  _id: ObjectId("507f1fg7bcf865d799439h12"), 
  title: "iPhone7", 
  price: 600,
  stock: 25 
},
{ 
  _id: ObjectId("507f1fg7bcf865d799439h13"), 
  title: "iPhone6", 
  price: 500,
  stock: 25 
}

To start an update operation, we must first choose our filter. This is similar to when we used find() to retrieve a document based on specific criteria. So, for example, if we wanted to update only the document with the title "IPhoneX", we could specify the title as the filter:

db.products.updateOne({ title: "iPhoneX" }, <update>, <options> });

Now that we have a document we can target for the update, we can move onto the update parameter.

To update a document in MongoDB, we have to specify what fields we want to update and how we want to update them. This is where the update parameter comes into play. To specify how we want to update a document, we can use MongoDB update operators. MongoDB offers us several update operators that can perform a variety of modifications to document fields. In this exercise, we’ll focus on the $set update operator. This operator allows us to replace a field’s value with one that we provide.

To see this in action, imagine a new phone model is launching soon, and the price of the "iPhoneX" will need to be decreased in order to remain competitive. We want to update the price from 1000 to 679. We can accomplish this by running the following command:

db.products.updateOne({ title: "iPhoneX" }, { $set: { price: 679 } });

If successful, the operation should return:

{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

After running the previous command, we could query for the item to confirm the update was successful:

db.products.findOne({ title: "iPhoneX" })

And find our document was updated:

{ 
  _id: ObjectId("507f1fg7bcf865d799439h11"),
  title: "iPhoneX", 
  price: 679 
}

In this case, querying on the title field works fine, assuming the value is unique for every document. Usually, we want to be as specific as possible with our filtering criteria, so we can include multiple fields to add more specificity to our search. Remember that even if multiple documents match the filter criteria, only a single one (the first match) will be updated.

Note: While exploring the updateOne() command, we didn’t cover the use of the <options> parameter. This is because these fields are optional and aren’t required to perform the base action of updating a record. To explore the <options> parameter further, visit the MongoDB documentation for the updateOne() method.

Let’s practice updating using the updateOne() method by returning to our restaurants database.

Instructions
Checkpoint 1 Passed
1.
Connect to the restaurants database. Then, use the .findOne() method to query for the document with the restaurant_id of "50014008" from the listingsAndReviews collection.


Hint
To query a collection for a single document using the findOne() method, you can use the following syntax:

db.<collection>.findOne({ <field>: <value> })

Need another hint?
You can call the .findOne() method on the listingsAndReviews collection to query for a single document. Be sure to query on the restaurant_id field and provide a value of "50014008".

Once you put it together, your query should look like this:

db.listingsAndReviews.findOne({ restaurant_id: "50014008" });

Checkpoint 2 Passed
2.
The cuisine of this restaurant is incorrect. Update the value of the restaurant’s cuisinefield to“American”`.


Hint
Use the .updateOne() method to update a single document in a MongoDB collection. Use the restaurant_id field as the filter and the $set operator to replace the value for the field cuisine.

Need another hint?
As the first argument, provide a query document that specifies the `restaurant_id` field. As the second argument, provide an update document that uses the `$set` operator to update the `cuisine` field.
Once you put it together, your query should look as follows:

db.listingsAndReviews.updateOne({ restaurant_id: "50014008" }, { $set: { cuisine: "American" } })

Checkpoint 3 Passed
3.
Query the listingsAndReviews collection for the document to ensure it was updated!


Hint
To query a collection for a single document using the findOne() method, you can use the following syntax:

db.<collection>.findOne({ <field>: <value> })

Need another hint?
You can call the .findOne() method on the listingsAndReviews collection to query for a single document. Be sure to query on the restaurant_id field and provide a value of "50014008".

Once you put it together, your query should look like this:

mongosh
-------
est> use restaurants;
switched to db restaurants
restaurants> db.listingsAndReviews.findOne({restaurant_id: "50014008" });
{
  _id: ObjectId("5eb3d669b31de5d588f484e0"),
  address: {
    building: '770',
    coord: [ -74.00959999999999, 40.636179 ],
    street: '59 Street',
    zipcode: '11220'
  },
  borough: 'Brooklyn',
  cuisine: 'Chinese',
  grades: [
    {
      date: ISODate("2014-10-09T00:00:00.000Z"),
      grade: 'Z',
      score: 22
    }
  ],
  name: 'D.C.Plzz Seafood',
  restaurant_id: '50014008'
}
restaurants> db.listingsAndReviews.updateOne({restaurant_id: "50014008"}, {$set: {cuisine: "American"}});
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 0,
  upsertedCount: 0
}
restaurants> db.listingsAndReviews.findOne({restaurant_id: "50014008" });
{
  _id: ObjectId("5eb3d669b31de5d588f484e0"),
  address: {
    building: '770',
    coord: [ -74.00959999999999, 40.636179 ],
    street: '59 Street',
    zipcode: '11220'
  },
  borough: 'Brooklyn',
  cuisine: 'American',
  grades: [
    {
      date: ISODate("2014-10-09T00:00:00.000Z"),
      grade: 'Z',
      score: 22
    }
  ],
  name: 'D.C.Plzz Seafood',
  restaurant_id: '50014008'
}
restaurants> 

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Updates on Embedded Documents and Arrays
------------------------------------------
11 min
While updating a single document using a single field is helpful, MongoDB also stores data inside of embedded documents. So, what if we want to update a specific field in an embedded 
document? Consider the following document within a collection named furniture:

{
  _id: ObjectId("3ldh1fg733kf65d7994393ld"),
  name: "bedframe",
  dimensions: {
    length: 75,
    width: 38
  }
}

Let’s say we wanted to update the width field inside the dimensions embedded document. We could run the following command:

db.furniture.updateOne(
  { name: "bedframe" },
  { $set: { "dimensions.width": 54 }}
);

We can successfully target the width field inside the dimensions embedded document using dot notation.

MongoDB also stores data inside of arrays! If we instead want to update a value within an array, we can use dot notation to access the index of the element we want to update. Let’s look 
at the following example document for a collection named nbateams:

{
  _id: ObjectId("402h1fg73cf865d799439k42"),
  team: "Chicago Bulls",
  championships: [1991, 1902, 1993, 1996, 1997, 1998]
}

If we want to update the 2nd element (1902) of the championships array to the correct year, 1992, we could run the following command:

db.nbateams.updateOne(
  { team: "Chicago Bulls" }, 
  { $set: {"championships.1": 1992 }}
)

Once again, the embedded document’s name and the array index must be wrapped in quotations for the command to be successful. Note that we’re using the index of 1 since the year 1902 is 
the second element of the array, and arrays start at index 0.

Let’s practice updating embedded fields and arrays in our restaurants database!

* Instructions
--------------
Checkpoint 1 Passed
1.
Connect to the restaurants database. Then, using the listingsAndReviews collection, query for a document with a restaurant_id field with the value"40561796". Observe the properties of the 
document you find!


Hint
To query a collection for a single document using the findOne() method, you can use the following syntax:

db.<collection>.findOne({ <field>: <value> })

Need another hint?
You can call the .findOne() method on the listingsAndReviews collection to query for a single document. Be sure to query on the restaurant_id field and provide a value of "40561796".

Once you put it together, your query should look like this:

db.listingsAndReviews.findOne({ restaurant_id: "40561796" });

Checkpoint 2 Passed
2.
The street address for this restaurant is incorrect. Update the street value from "36 Street" to "58 street".


Hint
You can call the .updateOne() method on the listingsAndReviews collection to update a document in this collection. Use the restaurant_id field as the filter and the $set operator to 
replace the value for the embedded field address.

Need another hint?
As the first argument, provide a query document that specifies the restaurant_id. As the second argument, use the $set operator to update the street field.

The street field is embedded within the address field. Use dot notation to access it. Be sure to wrap the parent and nested fields in quotation marks.

Once you put it together, your query should look like this:

db.listingsAndReviews.updateOne({ restaurant_id: "40561796" }, { $set: { "address.street": "58 street" } })

Checkpoint 3 Passed
3.
Query the collection using the findOne() method for the document that was just updated to confirm this information was updated correctly.


Hint
To query a collection for a single document using the findOne() method, you can use the following syntax:

db.<collection>.findOne({ <field>: <value> })

Need another hint?
You can call the .findOne() method on the listingsAndReviews collection to query for a single document. Be sure to query on the restaurant_id field and provide a value of "40561796".

Once you put it together, your query should look like this:

db.listingsAndReviews.findOne({ restaurant_id: "40561796" });


mongosh
-------
test> use restaurants
switched to db restaurants
restaurants> db.listingsAndReviews.findOne({restaurant_id: "40561796"});
{
  _id: ObjectId("5eb3d668b31de5d588f4305b"),
  address: {
    building: '3290',
    coord: [ -73.92430569999999, 40.7565317 ],
    street: '59 street',
    zipcode: '11106'
  },
  borough: 'Queens',
  cuisine: 'Mediterranean',
  grades: [
    {
      date: ISODate("2014-06-25T00:00:00.000Z"),
      grade: 'B',
      score: 27
    },
    {
      date: ISODate("2013-12-12T00:00:00.000Z"),
      grade: 'A',
      score: 12
    },
    {
      date: ISODate("2013-07-03T00:00:00.000Z"),
      grade: 'A',
      score: 13
    },
    {
      date: ISODate("2013-01-16T00:00:00.000Z"),
      grade: 'A',
      score: 10
    },
    {
      date: ISODate("2012-08-03T00:00:00.000Z"),
      grade: 'B',
      score: 14
    }
  ],
  name: 'Cafe Bar',
  restaurant_id: '40561796'
}
restaurants> db.listingsAndReviews.updateOne({restaurant_id: "40561796"},{$set: {"address.street": "58 street"}});
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 0,
  upsertedCount: 0
}
restaurants> db.listingsAndReviews.findOne({restaurant_id: "40561796"});
{
  _id: ObjectId("5eb3d668b31de5d588f4305b"),
  address: {
    building: '3290',
    coord: [ -73.92430569999999, 40.7565317 ],
    street: '58 street',
    zipcode: '11106'
  },
  borough: 'Queens',
  cuisine: 'Mediterranean',
  grades: [
    {
      date: ISODate("2014-06-25T00:00:00.000Z"),
      grade: 'B',
      score: 27
    },
    {
      date: ISODate("2013-12-12T00:00:00.000Z"),
      grade: 'A',
      score: 12
    },
    {
      date: ISODate("2013-07-03T00:00:00.000Z"),
      grade: 'A',
      score: 13
    },
    {
      date: ISODate("2013-01-16T00:00:00.000Z"),
      grade: 'A',
      score: 10
    },
    {
      date: ISODate("2012-08-03T00:00:00.000Z"),
      grade: 'B',
      score: 14
    }
  ],
  name: 'Cafe Bar',
  restaurant_id: '40561796'
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Updating an Array with New Elements
-------------------------------------
13 min
MongoDB provides different array update operators that we can use with the .updateOne() method. In the earlier exercises, we learned to use the $set operator to replace a value. In this 
exercise, we’ll look at the $push operator.

The $push operator adds (or “pushes”) new elements to the end of an array. It can be used with the .updateOne() method with the following syntax:

db.<collection>.updateOne(
  <filter>,
  { $push: { <field1>: <value1>, ... } }
);

Consider a collection, automobiles, holding a document with data regarding specific car models:

{
  _id: ObjectId("627934bbfd6a8619040cc287"),
  make: "Audi",
  model: "A1",
  year: [2017, 2019]
}

If we wanted to add a new year into the array, we could use the $push operator to accomplish this:

db.vehicles.updateOne(
  { make: "Audi" },
  { $push: { year: 2020 }}
);

The updated document would look as follows:

{
  _id: ObjectId("627934bbfd6a8619040cc287"),
  make: "Audi",
  model: "A1",
  year: [2017, 2019, 2020]
}

It’s important to note that if the mentioned field is absent in the document to update, the $push operator adds this field to the document as an array and includes the given value as its 
element.

For example, consider our document from the automobiles collection again. Let’s say we wanted to update the country that manufactures this make of vehicle using the following command:

db.vehicles.updateOne(
  { make: "Audi" },
  { $push: { country: "Germany" }}
);

Because our document did not previously have a field called country, running this command would add the new field to the document as an array and insert one element, the string "Germany". 
Our output would look as follows:

{
  _id: ObjectId("627934bbfd6a8619040cc287"),
  make: "Audi",
  model: "A1",
  year: [2017, 2019, 2020],
  country: [ "Germany" ]
}

Let’s practice updating array fields with the $push operator with documents in our restaurants database!

* Instructions
--------------
Checkpoint 1 Passed
1.
Connect to the restaurants database. Then, using the .findOne() method on the listingsAndReviews collection, find the document with the field name with the value of "Cafe Bar". Observe 
the properties of the document!


Hint
Be sure to connect to the restaurants database first. To query a collection for a single document using the findOne() method, you can use the following syntax:

db.<collection>.findOne({ <field>: <value> })

Need another hint?
Be sure to pass in a query document as the first argument. Include the name field with a value of "Cafe Bar".

Once you put it together, your query should look like this:

db.listingsAndReviews.findOne({ name: "Cafe Bar" })

Checkpoint 2 Passed
2.
Cafe Bar recently got examined again and received a new grade. Insert a new element into the grades array with the following properties:

date: new Date(),
grade: "B",
score: 81


Hint
Make sure to use the $push operator with the .updateOne() method to add a new document to an array field. Here is the syntax:

db.<collection>.updateOne(
  <filter>,
  { $push: { <field1>: <value1>, ... } }
);

Need another hint?
Update the grades array field with a document that specifies the date, grade, and score fields.

Once you put it together, your query should look like this:

db.listingsAndReviews.updateOne({ name: "Cafe Bar" }, { $push: { grades: { date: new Date(), grade: "B", score: 81 } } })

Checkpoint 3 Passed
3.
Print out the same document using the name of the restaurant in order to see the updated values.


Hint
Be sure to connect to the restaurants database first. To query a collection for a single document using the findOne() method, you can use the following syntax:

db.<collection>.findOne({ <field>: <value> })

Need another hint?
Be sure to pass in a query document as the first argument. Include the name field with a value of "Cafe Bar".

Once you put it together, your query should look like this:

db.listingsAndReviews.findOne({ name: "Cafe Bar" })

mongosh
-------
test> use restaurants
switched to db restaurants
restaurants> db.listingsAndReviews.findOne({name: "Cafe Bar"});
{
  _id: ObjectId("5eb3d668b31de5d588f4305b"),
  address: {
    building: '3290',
    coord: [ -73.92430569999999, 40.7565317 ],
    street: '36 Street',
    zipcode: '11106'
  },
  borough: 'Queens',
  cuisine: 'Mediterranean',
  grades: [
    {
      date: ISODate("2014-06-25T00:00:00.000Z"),
      grade: 'B',
      score: 27
    },
    {
      date: ISODate("2013-12-12T00:00:00.000Z"),
      grade: 'A',
      score: 12
    },
    {
      date: ISODate("2013-07-03T00:00:00.000Z"),
      grade: 'A',
      score: 13
    },
    {
      date: ISODate("2013-01-16T00:00:00.000Z"),
      grade: 'A',
      score: 10
    },
    {
      date: ISODate("2012-08-03T00:00:00.000Z"),
      grade: 'B',
      score: 14
    },
    {
      date: ISODate("2024-04-22T13:18:29.184Z"),
      grade: 'B',
      score: 81
    }
  ],
  name: 'Cafe Bar',
  restaurant_id: '40561796'
}
restaurants> db.listingsAndReviews.updateOne({name: "Cafe Bar"},{$push: {grades: {date: new Date(), grade: "B", score: 81}}});
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
restaurants> db.listingsAndReviews.findOne({name: "Cafe Bar"});
{
  _id: ObjectId("5eb3d668b31de5d588f4305b"),
  address: {
    building: '3290',
    coord: [ -73.92430569999999, 40.7565317 ],
    street: '36 Street',
    zipcode: '11106'
  },
  borough: 'Queens',
  cuisine: 'Mediterranean',
  grades: [
    {
      date: ISODate("2014-06-25T00:00:00.000Z"),
      grade: 'B',
      score: 27
    },
    {
      date: ISODate("2013-12-12T00:00:00.000Z"),
      grade: 'A',
      score: 12
    },
    {
      date: ISODate("2013-07-03T00:00:00.000Z"),
      grade: 'A',
      score: 13
    },
    {
      date: ISODate("2013-01-16T00:00:00.000Z"),
      grade: 'A',
      score: 10
    },
    {
      date: ISODate("2012-08-03T00:00:00.000Z"),
      grade: 'B',
      score: 14
    },
    {
      date: ISODate("2024-04-22T13:18:29.184Z"),
      grade: 'B',
      score: 81
    },
    {
      date: ISODate("2024-04-22T13:20:34.419Z"),
      grade: 'B',
      score: 81
    }
  ],
  name: 'Cafe Bar',
  restaurant_id: '40561796'
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Upserting a Document
----------------------
10 min
In the previous exercises, we looked at different ways to update and insert data into a collection. Now, we’ll learn about combining both operations using upsert.

The upsert option is an optional parameter we can use with update methods such as .updateOne(). It accepts a boolean value, and if assigned to true, upsert will give our .updateOne() 
method the following behavior:

	1. Update data if there is a matching document.

	2. Insert a new document if there’s no match based on the query criteria.

Let’s take a look at its syntax below:

db.<collection>.updateOne(
  <filter>, 
  <update>, 
  { upsert: <boolean> }
);

The upsert parameter is false by default. If the property is omitted, the method will only update the documents that match the query. If no existing documents match the query, the 
operation will complete without making any changes to the data.

To see the upsert option in action, consider a collection named pets, holding a large number of documents with the following structure:

{
  _id: ObjectId(...),
  name: "Luna",
  type: "Cat",
  age: 2
}

Imagine it’s Luna’s birthday, and we want to be sure that we capture her current age, but we aren’t sure whether or not we have an existing document for her. This would be an excellent 
opportunity to use upsert since one of two things will happen:

	. If Luna does not exist in the database, our command will create the document

	. If Luna does exist, the document will be updated

To upsert our document for Luna, we can call the .updateOne() command as follows:

db.pets.updateOne(
  { name: "Luna", type: "Cat"},
  { $set: { age: 3 }},
  { upsert: true }
)

As noted, this command would search our pets collection for a document where the name is "Luna" and the type is "Cat". If such a document exists, its age field would be updated. 
Otherwise, the following document would be inserted into our collection:

{
  _id: ObjectId(...),
  name: "Luna",
  type: "Cat",
  age: 3
}

Let’s spend some time practicing using the upsert option with the .updateOne() method.

* Instructions
--------------
Checkpoint 1 Passed
1.
Connect to the restaurants database. Then, in the listingsAndReviews collection, find and update the restaurant with the name "Vinnys" to have the following properties. If the document 
does not exist, it should be added with these properties.

{
  borough: "Queens",
  cuisine: "Italian"
}


Hint
Be sure to connect to the restaurants database first. To query a collection for a single document using the findOne() method, you can use the following syntax:

db.<collection>.findOne({ <field>: <value> })

Need another hint?
Include an options document as the third parameter and set the upsert option to true to insert a document if it doesn’t already exist.

Once you put it together, your query should look like this:

db.listingsAndReviews.updateOne({ name: "Vinnys" }, { $set: { borough: "Queens", cuisine: "Italian" } }, { upsert: true })

Checkpoint 2 Passed
2.
Use the .findOne() method to query the collection for the newly updated document. Use the name field as the query.


Hint
You can use the command .findOne() to query a collection for a single document.

Need another hint?
Be sure to include a query document as the first parameter. Specify the name field with the value "Vinnys".

Once you put it together, your query should look like this:

mongosh
-------
test> use restaurants
switched to db restaurants
restaurants> db.listingsAndReviews.updateOne({name: "Vinnys"}, {$set: {borough: "Queens", cuisine: "Italian"}}, {upsert: true});
{
  acknowledged: true,
  insertedId: ObjectId("66277881efafce9061b96b5a"),
  matchedCount: 0,
  modifiedCount: 0,
  upsertedCount: 1
}
restaurants> db.listingsAndReviews.findOne({name: "Vinnys"});
{
  _id: ObjectId("66277881efafce9061b96b5a"),
  name: 'Vinnys',
  borough: 'Queens',
  cuisine: 'Italian'
}
restaurants> 

------------------------------------------------------------------------------------------------------------------------------------------------------------------










































































































































